package mockgen

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/JosiahWitt/ensure/cmd/ensure/internal/ifacereader"
	"github.com/JosiahWitt/ensure/cmd/ensure/internal/uniqpkg"
)

type templateParams struct {
	Package *ifacereader.Package
	Imports []*uniqpkg.ImportDetails

	ReflectPackageName string
	GoMockPackageName  string
}

//nolint:gochecknoglobals // Only read internally
var templateFuncs = template.FuncMap{
	"buildTypeParamsDeclaration":  templateFuncBuildTypeParamsDeclaration,
	"buildMockStructName":         templateFuncBuildMockStructName,
	"buildMockRecorderStructName": templateFuncBuildMockRecorderStructName,
	"buildInputSignature":         templateFuncBuildInputSignature,
	"buildMockInputSignature":     templateFuncBuildMockInputSignature,
	"buildInputsSlice":            templateFuncBuildInputsSlice,
	"buildOutputSignature":        templateFuncBuildOutputSignature,
	"buildMockReturns":            templateFuncBuildMockReturns,
	"buildParamsDoc":              templateFuncBuildParamsDoc,
}

//nolint:lll
const packageTemplate = `{{ $params := . -}}
// Code generated by ` + "`ensure mocks generate`" + `. DO NOT EDIT.
// Source: {{$params.Package.Path}} (interfaces: {{$params.InterfaceNames}})

// Package mock_{{$params.Package.Name}} is a generated GoMock package.
package mock_{{$params.Package.Name}}

import (
	{{$params.BuildImports}}
)
{{range $params.Package.Interfaces}}{{ $iface := . }}
// Mock{{$iface.Name}} is a mock of the {{$iface.Name}} interface in {{$params.Package.Path}}.
type Mock{{$iface.Name}}{{buildTypeParamsDeclaration $iface.TypeParams}} struct {
	ctrl     *{{$params.GoMockPackageName}}.Controller
	recorder *{{buildMockRecorderStructName $iface}}
}

// Mock{{$iface.Name}}MockRecorder is the mock recorder for Mock{{$iface.Name}}.
type Mock{{$iface.Name}}MockRecorder{{buildTypeParamsDeclaration $iface.TypeParams}} struct {
	mock *{{buildMockStructName $iface}}
}

// NewMock{{$iface.Name}} creates a new mock instance.
func NewMock{{$iface.Name}}{{buildTypeParamsDeclaration $iface.TypeParams}}(ctrl *{{$params.GoMockPackageName}}.Controller) *{{buildMockStructName $iface}} {
	mock := &{{buildMockStructName $iface}}{ctrl: ctrl}
	mock.recorder = &{{buildMockRecorderStructName $iface}}{mock}
	return mock
}

// NEW creates a Mock{{$iface.Name}}. This method is used internally by ensure.
func (*{{buildMockStructName $iface}}) NEW(ctrl *{{$params.GoMockPackageName}}.Controller) *{{buildMockStructName $iface}} {
	return New{{buildMockStructName $iface}}(ctrl)
}

// EXPECT returns a struct that allows setting up expectations.
func (m *{{buildMockStructName $iface}}) EXPECT() *{{buildMockRecorderStructName $iface}} {
	return m.recorder
}
{{range .Methods}}{{ $method := . }}
// {{$method.Name}} mocks {{$method.Name}} on {{$iface.Name}}.
func (m *{{buildMockStructName $iface}}) {{$method.Name}}({{buildInputSignature $method.Inputs}}){{buildOutputSignature $method.Outputs}} {
	m.ctrl.T.Helper()
	{{buildInputsSlice $method.Inputs}}
	ret := m.ctrl.Call(m, "{{$method.Name}}", inputs...)
	{{buildMockReturns $method.Outputs}}
}

// {{$method.Name}} sets up expectations for calls to {{$method.Name}}.
// Calling this method multiple times allows expecting multiple calls to {{$method.Name}} with a variety of parameters.
//
// Inputs:
//
//	{{buildParamsDoc $method.Inputs}}
//
// Outputs:
//
//	{{buildParamsDoc $method.Outputs}}
func (mr *{{buildMockRecorderStructName $iface}}) {{$method.Name}}({{buildMockInputSignature $method.Inputs}}) *{{$params.GoMockPackageName}}.Call {
	mr.mock.ctrl.T.Helper()
	{{buildInputsSlice $method.Inputs}}
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "{{$method.Name}}", {{$params.ReflectPackageName}}.TypeOf((*{{buildMockStructName $iface}})(nil).{{$method.Name}}), inputs...)
}
{{end -}}
{{end}}`

func (p *templateParams) InterfaceNames() string {
	interfaceNames := make([]string, 0, len(p.Package.Interfaces))
	for _, iface := range p.Package.Interfaces {
		interfaceNames = append(interfaceNames, iface.Name)
	}

	return strings.Join(interfaceNames, ", ")
}

func (p *templateParams) BuildImports() string {
	importLines := make([]string, 0, len(p.Imports))
	for _, importDetails := range p.Imports {
		importLine := fmt.Sprintf(`"%s"`, importDetails.Path)
		if importDetails.IsAlias {
			importLine = importDetails.Name + " " + importLine
		}

		importLines = append(importLines, importLine)
	}

	return strings.Join(importLines, "\n\t")
}

func templateFuncBuildTypeParamsDeclaration(typeParams []*ifacereader.TypeParam) string {
	return buildTypeParams(typeParams, func(typeParam *ifacereader.TypeParam) string {
		return typeParam.Name + " " + typeParam.Type
	})
}

func templateFuncBuildMockStructName(iface *ifacereader.Interface) string {
	typeParams := buildTypeParams(iface.TypeParams, func(typeParam *ifacereader.TypeParam) string {
		return typeParam.Name
	})

	return fmt.Sprintf("Mock%s%s", iface.Name, typeParams)
}

func templateFuncBuildMockRecorderStructName(iface *ifacereader.Interface) string {
	typeParams := buildTypeParams(iface.TypeParams, func(typeParam *ifacereader.TypeParam) string {
		return typeParam.Name
	})

	return fmt.Sprintf("Mock%sMockRecorder%s", iface.Name, typeParams)
}

func templateFuncBuildInputSignature(inputs []*ifacereader.Tuple) string {
	builtInputs := make([]string, 0, len(inputs))
	for _, input := range preprocessParams(inputs, false) {
		builtInputs = append(builtInputs, input.VariableName+" "+input.Type)
	}

	return strings.Join(builtInputs, ", ")
}

func templateFuncBuildMockInputSignature(inputs []*ifacereader.Tuple) string {
	if len(inputs) == 0 {
		return ""
	}

	builtInputs := make([]string, 0, len(inputs))
	for _, input := range preprocessParams(inputs, false) {
		inputType := "interface{}"
		if input.Variadic {
			inputType = "...interface{}"
		}

		builtInputs = append(builtInputs, input.VariableName+" "+inputType)
	}

	return strings.Join(builtInputs, ", ")
}

func templateFuncBuildInputsSlice(inputs []*ifacereader.Tuple) string {
	nonVariadicVariables := make([]string, 0, len(inputs))
	variadicVariable := ""

	for _, input := range preprocessParams(inputs, false) {
		if input.Variadic {
			// Skip adding the variadic input to the list, since we need to use a loop to get around type issues
			variadicVariable = input.VariableName
			continue
		}

		nonVariadicVariables = append(nonVariadicVariables, input.VariableName)
	}

	builtInputs := "inputs := []interface{}{" + strings.Join(nonVariadicVariables, ", ") + "}"

	if variadicVariable != "" {
		builtInputs += "\n\tfor _, variadicInput := range " + variadicVariable + " {\n" +
			"\t\tinputs = append(inputs, variadicInput)\n" +
			"\t}"
	}

	return builtInputs
}

func templateFuncBuildOutputSignature(outputs []*ifacereader.Tuple) string {
	if len(outputs) == 0 {
		return ""
	}

	builtOutputs := make([]string, 0, len(outputs))
	for _, output := range outputs {
		builtOutput := output.Type
		if output.VariableName != "" {
			// Prefix output parameters with `_` to prevent clashing with internal variables inside our mocks
			builtOutput = fmt.Sprintf("_%s %s", output.VariableName, output.Type)
		}

		builtOutputs = append(builtOutputs, builtOutput)
	}

	outputList := strings.Join(builtOutputs, ", ")
	if len(builtOutputs) > 1 {
		outputList = fmt.Sprintf("(%s)", outputList)
	}

	return " " + outputList
}

func templateFuncBuildMockReturns(outputs []*ifacereader.Tuple) string {
	if len(outputs) == 0 {
		return "var _ = ret // Unused, since there are no returns\n\treturn"
	}

	builtAssertions := make([]string, 0, len(outputs))
	builtReturns := make([]string, 0, len(outputs))

	for i, output := range outputs {
		builtAssertion := fmt.Sprintf("ret%d, _ := ret[%d].(%s)", i, i, output.Type)
		builtAssertions = append(builtAssertions, builtAssertion)

		builtReturns = append(builtReturns, fmt.Sprintf("ret%d", i))
	}

	assertions := strings.Join(builtAssertions, "\n\t")
	returns := "return " + strings.Join(builtReturns, ", ")
	return assertions + "\n\t" + returns
}

func templateFuncBuildParamsDoc(params []*ifacereader.Tuple) string {
	if len(params) == 0 {
		return "none"
	}

	builtParams := make([]string, 0, len(params))
	for _, param := range preprocessParams(params, true) {
		builtParam := param.Type
		if param.VariableName != "" {
			builtParam = param.VariableName + " " + param.Type
		}

		builtParams = append(builtParams, builtParam)
	}

	return strings.Join(builtParams, "\n//	")
}

func preprocessParams(params []*ifacereader.Tuple, originalVarName bool) []*ifacereader.Tuple {
	populatedParams := make([]*ifacereader.Tuple, 0, len(params))
	for i, originalParam := range params {
		param := *originalParam

		if !originalVarName {
			if param.VariableName == "" {
				param.VariableName = fmt.Sprintf("arg%d", i)
			}

			// Prefix variable names with `_` to prevent clashing with internal variables inside our mocks
			param.VariableName = "_" + param.VariableName
		}

		if param.Variadic {
			param.Type = "..." + strings.TrimPrefix(param.Type, "[]")
		}

		populatedParams = append(populatedParams, &param)
	}

	return populatedParams
}

func buildTypeParams(typeParams []*ifacereader.TypeParam, transform func(*ifacereader.TypeParam) string) string {
	if len(typeParams) == 0 {
		return ""
	}

	builtTypeParams := make([]string, 0, len(typeParams))
	for _, typeParam := range typeParams {
		builtTypeParams = append(builtTypeParams, transform(typeParam))
	}

	return "[" + strings.Join(builtTypeParams, ", ") + "]"
}
