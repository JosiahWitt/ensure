package mockgen

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/JosiahWitt/ensure/cmd/ensure/internal/ifacereader"
	"github.com/JosiahWitt/ensure/cmd/ensure/internal/uniqpkg"
)

type templateParams struct {
	Package *ifacereader.Package
	Imports []*uniqpkg.ImportDetails

	ReflectPackageName string
	GoMockPackageName  string
}

var templateFuncs = template.FuncMap{
	"buildInputSignature":     templateFuncBuildInputSignature,
	"buildMockInputSignature": templateFuncBuildMockInputSignature,
	"buildInputVariableList":  templateFuncBuildInputVariableList,
	"buildOutputSignature":    templateFuncBuildOutputSignature,
	"buildMockReturns":        templateFuncBuildMockReturns,
	"buildParamsDoc":          templateFuncBuildParamsDoc,
}

const packageTemplate = `{{ $params := . -}}
// Code generated by ` + "`ensure mocks generate`" + `. DO NOT EDIT.
// Source: {{$params.Package.Path}} (interfaces: {{$params.InterfaceNames}})

// Package mock_{{$params.Package.Name}} is a generated GoMock package.
package mock_{{$params.Package.Name}}

import (
	{{$params.BuildImports}}
)
{{range $params.Package.Interfaces}}{{ $iface := . }}
// Mock{{$iface.Name}} is a mock of the {{$iface.Name}} interface in {{$params.Package.Path}}.
type Mock{{$iface.Name}} struct {
	ctrl     *{{$params.GoMockPackageName}}.Controller
	recorder *Mock{{$iface.Name}}MockRecorder
}

// Mock{{$iface.Name}}MockRecorder is the mock recorder for Mock{{$iface.Name}}.
type Mock{{$iface.Name}}MockRecorder struct {
	mock *Mock{{$iface.Name}}
}

// NewMock{{$iface.Name}} creates a new mock instance.
func NewMock{{$iface.Name}}(ctrl *{{$params.GoMockPackageName}}.Controller) *Mock{{$iface.Name}} {
	mock := &Mock{{$iface.Name}}{ctrl: ctrl}
	mock.recorder = &Mock{{$iface.Name}}MockRecorder{mock}
	return mock
}

// NEW creates a Mock{{$iface.Name}}. This method is used internally by ensure.
func (*Mock{{$iface.Name}}) NEW(ctrl *{{$params.GoMockPackageName}}.Controller) *Mock{{$iface.Name}} {
	return NewMock{{$iface.Name}}(ctrl)
}

// EXPECT returns a struct that allows setting up expectations.
func (m *Mock{{$iface.Name}}) EXPECT() *Mock{{$iface.Name}}MockRecorder {
	return m.recorder
}
{{range .Methods}}{{ $method := . }}
// {{$method.Name}} mocks {{$method.Name}} on {{$iface.Name}}.
func (m *Mock{{$iface.Name}}) {{$method.Name}}({{buildInputSignature $method.Inputs}}){{buildOutputSignature $method.Outputs}} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "{{$method.Name}}"{{buildInputVariableList $method.Inputs}})
	{{buildMockReturns $method.Outputs}}
}

// {{$method.Name}} sets up expectations for calls to {{$method.Name}}.
// Calling this method multiple times allows expecting multiple calls to {{$method.Name}} with a variety of parameters.
//
// Inputs:
//
//  {{buildParamsDoc $method.Inputs}}
//
// Outputs:
//
//  {{buildParamsDoc $method.Outputs}}
func (mr *Mock{{$iface.Name}}MockRecorder) {{$method.Name}}({{buildMockInputSignature $method.Inputs}}) *{{$params.GoMockPackageName}}.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "{{$method.Name}}", {{$params.ReflectPackageName}}.TypeOf((*Mock{{$iface.Name}})(nil).{{$method.Name}}){{buildInputVariableList $method.Inputs}})
}
{{end -}}
{{end}}`

func (p *templateParams) InterfaceNames() string {
	interfaceNames := make([]string, 0, len(p.Package.Interfaces))
	for _, iface := range p.Package.Interfaces {
		interfaceNames = append(interfaceNames, iface.Name)
	}

	return strings.Join(interfaceNames, ", ")
}

func (p *templateParams) BuildImports() string {
	importLines := make([]string, 0, len(p.Imports))
	for _, importDetails := range p.Imports {
		importLine := fmt.Sprintf(`"%s"`, importDetails.Path)
		if importDetails.IsAlias {
			importLine = importDetails.Name + " " + importLine
		}

		importLines = append(importLines, importLine)
	}

	return strings.Join(importLines, "\n\t")
}

func templateFuncBuildInputSignature(inputs []*ifacereader.Tuple) string {
	builtInputs := make([]string, 0, len(inputs))
	for _, input := range populateVariableNames(inputs) {
		builtInputs = append(builtInputs, input.VariableName+" "+input.Type)
	}

	return strings.Join(builtInputs, ", ")
}

func templateFuncBuildMockInputSignature(inputs []*ifacereader.Tuple) string {
	if len(inputs) == 0 {
		return ""
	}

	builtInputs := buildInputVariableList(inputs)
	return builtInputs + " interface{}"
}

func templateFuncBuildInputVariableList(inputs []*ifacereader.Tuple) string {
	if len(inputs) == 0 {
		return ""
	}

	builtInputs := buildInputVariableList(inputs)
	return ", " + builtInputs
}

func buildInputVariableList(inputs []*ifacereader.Tuple) string {
	builtInputs := make([]string, 0, len(inputs))
	for _, input := range populateVariableNames(inputs) {
		builtInputs = append(builtInputs, input.VariableName)
	}

	return strings.Join(builtInputs, ", ")
}

func templateFuncBuildOutputSignature(outputs []*ifacereader.Tuple) string {
	if len(outputs) == 0 {
		return ""
	}

	builtOutputs := make([]string, 0, len(outputs))
	for _, output := range outputs {
		builtOutput := output.Type
		if output.VariableName != "" {
			// Prefix output parameters with `_` to prevent clashing with internal variables inside our mocks
			builtOutput = fmt.Sprintf("_%s %s", output.VariableName, output.Type)
		}

		builtOutputs = append(builtOutputs, builtOutput)
	}

	outputList := strings.Join(builtOutputs, ", ")
	if len(builtOutputs) > 1 {
		outputList = fmt.Sprintf("(%s)", outputList)
	}

	return " " + outputList
}

func templateFuncBuildMockReturns(outputs []*ifacereader.Tuple) string {
	if len(outputs) == 0 {
		return "var _ = ret // Unused, since there are no returns\n\treturn"
	}

	builtAssertions := make([]string, 0, len(outputs))
	builtReturns := make([]string, 0, len(outputs))

	for i, output := range outputs {
		builtAssertion := fmt.Sprintf("ret%d, _ := ret[%d].(%s)", i, i, output.Type)
		builtAssertions = append(builtAssertions, builtAssertion)

		builtReturns = append(builtReturns, fmt.Sprintf("ret%d", i))
	}

	assertions := strings.Join(builtAssertions, "\n\t")
	returns := "return " + strings.Join(builtReturns, ", ")
	return assertions + "\n\t" + returns
}

func templateFuncBuildParamsDoc(params []*ifacereader.Tuple) string {
	if len(params) == 0 {
		return "none"
	}

	builtParams := make([]string, 0, len(params))
	for _, param := range params {
		builtParam := param.Type
		if param.VariableName != "" {
			builtParam = param.VariableName + " " + param.Type
		}

		builtParams = append(builtParams, builtParam)
	}

	return strings.Join(builtParams, "\n//  ")
}

func populateVariableNames(inputs []*ifacereader.Tuple) []*ifacereader.Tuple {
	populatedInputs := make([]*ifacereader.Tuple, 0, len(inputs))
	for i, input := range inputs {
		varName := input.VariableName
		if varName == "" {
			varName = fmt.Sprintf("arg%d", i)
		}

		populatedInputs = append(populatedInputs, &ifacereader.Tuple{
			VariableName: "_" + varName, // Prefix variable names with `_` to prevent clashing with internal variables inside our mocks
			Type:         input.Type,
			PackagePaths: input.PackagePaths,
		})
	}

	return populatedInputs
}
